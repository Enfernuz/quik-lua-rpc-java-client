syntax = "proto3";

import "quik-lua-rpc/messages/qlua_structures.proto";

package qlua.procs;

enum ProcedureType {

    PROCEDURE_TYPE_UNKNOWN = 0;
    IS_CONNECTED = 1;
    GET_SCRIPT_PATH = 2;
    GET_INFO_PARAM = 3;
    MESSAGE = 4;
    SLEEP = 5;
    GET_WORKING_FOLDER = 6;
    PRINT_DBG_STR = 7;
    GET_ITEM = 8;
    GET_ORDER_BY_NUMBER = 9; // NOT TESTED YET
    GET_NUMBER_OF = 10;
    SEARCH_ITEMS = 11;
    GET_CLASSES_LIST = 12;
    GET_CLASS_INFO = 13;
    GET_CLASS_SECURITIES = 14;
    GET_MONEY = 15;
    GET_MONEY_EX = 16;
    GET_DEPO = 17;
    GET_DEPO_EX = 18;
    GET_FUTURES_LIMIT = 19;
    GET_FUTURES_HOLDING = 20;
    GET_SECURITY_INFO = 21;
    GET_TRADE_DATE = 22;
    GET_QUOTE_LEVEL2 = 23;
    
    GET_LINES_COUNT = 24;
    GET_NUM_CANDLES = 25;
    GET_CANDLES_BY_INDEX = 26;
    
    CREATE_DATA_SOURCE = 27;
    DS_SET_UPDATE_CALLBACK = 28;
    DS_O = 29;
    DS_H = 30;
    DS_L = 31;
    DS_C = 32;
    DS_V = 33;
    DS_T = 34;
    DS_SIZE = 35;
    DS_CLOSE = 36;
    DS_SET_EMPTY_CALLBACK = 37;
    
    SEND_TRANSACTION = 38;
    CALC_BUY_SELL = 39; // NOT TESTED YET
    
    GET_PARAM_EX = 40;
    GET_PARAM_EX_2 = 41; // NB: использовать структуры запроса и ответа от GET_PARAM_EX
    
    GET_PORTFOLIO_INFO = 42;
    GET_PORTFOLIO_INFO_EX = 43;
    
    GET_BUY_SELL_INFO = 44;
    GET_BUY_SELL_INFO_EX = 45; // NB: использовать структуры запроса и ответа от GET_BUY_SELL_INFO
    
    ADD_COLUMN = 46; // нужно бы ещё потестить, т.к. после добавления одного столбца другие добавляются, но визуально не отображаются
    ALLOC_TABLE = 47;
    CLEAR = 48;
    CREATE_WINDOW = 49;
    DELETE_ROW = 50;
    DESTROY_TABLE = 51;
    INSERT_ROW = 52; // NB: использовать после создания окна для таблицы (процедура CREATE_WINDOW)
    IS_WINDOW_CLOSED = 53;
    GET_CELL = 54;
    GET_TABLE_SIZE = 55;
    GET_WINDOW_CAPTION = 56;
    GET_WINDOW_RECT = 57;
    SET_CELL = 58;
    SET_WINDOW_CAPTION = 59;
    SET_WINDOW_POS = 60;
    SET_TABLE_NOTIFICATION_CALLBACK = 61;
    RGB = 62; // NB: на самом деле, библиотечная функция RGB должна называться BGR, ибо она выдаёт числа именно в этом формате. В SetColor, однако, тоже ожидается цвет в формате BGR, так что это не баг, а фича.
    SET_COLOR = 63;
    HIGHLIGHT = 64;
    SET_SELECTED_ROW = 65;

    ADD_LABEL = 66;
    DEL_LABEL = 67;
    DEL_ALL_LABELS = 68;
    GET_LABEL_PARAMS = 69;
    SET_LABEL_PARAMS = 70;
    
    SUBSCRIBE_LEVEL_II_QUOTES = 71; // NOT IMPLEMENTED YET
    UNSUBSCRIBE_LEVEL_II_QUOTES = 72; // NOT IMPLEMENTED YET
    IS_SUBSCRIBED_LEVEL_II_QUOTES = 73; // NOT IMPLEMENTED YET
    
    PARAM_REQUEST = 74;
    CANCEL_PARAM_REQUEST = 75;
    
    BIT_TOHEX = 76;
    BIT_BNOT = 77;
    BIT_BAND = 78;
    BIT_BOR = 79;
    BIT_BXOR = 80;
}

// Не получилось внедрить это определение в AddColumn_Request, т.к. не смог потом залукапить значения енама
enum ColumnParameterType {

    COLUMN_PARAMETER_TYPE_UNKNOWN = 0;
    QTABLE_INT_TYPE = 1;
    QTABLE_DOUBLE_TYPE = 2;
    QTABLE_INT64_TYPE = 3;
    QTABLE_CACHED_STRING_TYPE = 4;
    QTABLE_TIME_TYPE = 5;
    QTABLE_DATE_TYPE = 6;
    QTABLE_STRING_TYPE = 7;
}

enum Interval {

    INTERVAL_UNKNOWN = 0;
    INTERVAL_TICK = 1;
    INTERVAL_M1 = 2;
    INTERVAL_M2 = 3;
    INTERVAL_M3 = 4;
    INTERVAL_M4 = 5;
    INTERVAL_M5 = 6;
    INTERVAL_M6 = 7;
    INTERVAL_M10 = 8;
    INTERVAL_M15 = 9;
    INTERVAL_M20 = 10;
    INTERVAL_M30 = 11;
    INTERVAL_H1 = 12;
    INTERVAL_H2 = 13;
    INTERVAL_H4 = 14;
    INTERVAL_D1 = 15;
    INTERVAL_W1 = 16;
    INTERVAL_MN1 = 17;
}

enum MessageIconType {

    MESSAGE_ICON_TYPE_UNDEFINED = 0;
    MESSAGE_ICON_TYPE_INFO = 1;
    MESSAGE_ICON_TYPE_WARNING = 2;
    MESSAGE_ICON_TYPE_ERROR = 3;
}

message Qlua_Request {

    ProcedureType type = 1;
    bytes args = 2; // the protoc-lua-plugin gives out a corrupted .lua file if we're using google.protobuf.Any
}

message Qlua_Response {

    ProcedureType type = 1;
    bool is_error = 2;
    bytes result = 3;
}

message IsConnected_Result {
    int32 is_connected = 1;
}

message GetScriptPath_Result {
    string script_path = 1;
}

message GetInfoParam_Request {

    // Хотел сделать enum-ом, чтобы меньше слать по wire, но в используемой Lua-реализации
    // protobuf'a нет адекватного способа вернуть строковое имя enum'а, поэтому говнокод, который
    // надо будет для этого написать, скорее всего нивелирует какой-либо перфомансный 
    // профит от enum'ов в данном случае. К тому же, при добавлении новых видов paramName 
    // при использовании строк ничего не надо будет перекомпилировать.
    string param_name = 1;  
}

message GetInfoParam_Result {
    string info_param = 1;
}

message Message_Request {

    string message = 1;
    MessageIconType icon_type = 2;
}

message Message_Result {
    int32 result = 1;
}

message Sleep_Request {
    int32 time = 1;
}

message Sleep_Result {
    int32 result = 1;
}

message GetWorkingFolder_Result {
    string working_folder = 1;
}

message PrintDbgStr_Request {
    string s = 1;
}

message GetItem_Request {

    string table_name = 1;
    int32 index = 2;
}

message GetItem_Result {
    map<string, string> table_row = 1;
}

message GetOrderByNumber_Request {

    string class_code = 1;
    uint32 order_id = 2;
}

message GetOrderByNumber_Result {

    qlua.structs.Order order = 1;
    int32 indx = 2;
}

message GetNumberOf_Request {
    string table_name = 1;
}

message GetNumberOf_Result {
    int32 result = 1;
}

message SearchItems_Request {

    string table_name = 1;
    int32 start_index = 2;
    
    // Для удобства 0 интерпретируется как getNumberOf(table_name) - 1
    int32 end_index = 3; 
    
    // Формат функции без использования params: "function (TABLE t) ... end", возвращаемые значения: BOOLEAN, nil; 
    // где t -- строка таблицы table_name со всеми параметрами.
    // Формат функции при использовании params: "function (p1, p2, ...) ... end", возвращаемые значения: BOOLEAN, nil; 
    // где p1, p2, ... -- значения параметров, заказанных в params
    
    // Внимание! По результам тестирования возврат nil из fn не приводит к ожидаемому результату (возврат списка уже пройденных индексов, удовлетворяющих условию + индекс, на котором возвратили nil + остановка процесса проверки условия) -- вместо этого процесс проверки условия прерывается и функция SearchItems возвращает nil. Подозреваю, что это баг в QLUA или ошибка в документации.
    string fn_def = 4; 
    
    string params = 5;
}

message SearchItems_Result {
    repeated int32 items_indices = 1; 
    //NB: Недоработка QLUA: пустой список индексов возвращается в виде nil, и ошибка при работе фукнции проверки элемента (fn)
    //тоже приводит к возврату nil, так что непонятно, не нашли ли мы удовлетворяющих условию элементов или написали ошибочную
    //функцию проверки условия. Для определённости, в обоих случаях будем возвращать пустой список.--]]
}

message GetClassesList_Result {
    string classes_list = 1;
}

message GetClassInfo_Request {
    string class_code = 1;
}

message GetClassInfo_Result {
    qlua.structs.Klass class_info = 1;
}

message GetClassSecurities_Request {
    string class_code = 1;
}

message GetClassSecurities_Result {
    string class_securities = 1;
}

message GetMoney_Request {

    string client_code = 1; // Код клиента
    string firmid = 2; // Фирма
    string tag = 3; // Группа
    string currcode = 4; // Валюта
}

message GetMoney_Result {

    message Money {
    
        string money_open_limit = 1; // NUMBER in QLUA
        string money_limit_locked_nonmarginal_value = 2; // NUMBER in QLUA
        string money_limit_locked = 3; // NUMBER in QLUA
        string money_open_balance = 4; // NUMBER in QLUA
        string money_current_limit = 5; // NUMBER in QLUA
        string money_current_balance = 6; // NUMBER in QLUA
        string money_limit_available = 7; // NUMBER in QLUA
    }

    Money money = 1;
}

message GetMoneyEx_Request {

    string firmid = 1; // Фирма
    string client_code = 2; // Код клиента
    string tag = 3; // Группа
    string currcode = 4; // Валюта
    int32 limit_kind = 5; // Вид лимита (Как задать лимит "Tx"? Ответ: видимо, никак -- это недоработка в API qlua)
}

message GetMoneyEx_Result {
    qlua.structs.MoneyLimit money_ex = 1;
}

message GetDepo_Request {

    string client_code = 1; // Код клиента
    string firmid = 2; // Фирма
    string sec_code = 3; // Код бумаги
    string trdaccid = 4; // Счет депо
}

message GetDepo_Result {

    message Depo {
        
        string depo_limit_locked_buy_value = 1;
        string depo_current_balance = 2;
        string depo_limit_locked_buy = 3;
        string depo_limit_locked = 4;
        string depo_limit_available = 5;
        string depo_current_limit = 6;
        string depo_open_balance = 7;
        string depo_open_limit = 8;
    }

    Depo depo = 1;
}

message GetDepoEx_Request {

    string firmid = 1; // Фирма
    string client_code = 2; // Код клиента
    string sec_code = 3; // Код бумаги
    string trdaccid = 4; // Счет депо
    int32 limit_kind = 5; // Вид лимита (Как задать лимит "Tx"? Ответ: видимо, никак -- это недоработка в API qlua)
}

message GetDepoEx_Result {
    qlua.structs.DepoLimit depo_ex = 1;
}

message GetFuturesLimit_Request {

    string firmid = 1;
    string trdaccid = 2;
    int32 limit_type = 3;
    string currcode = 4;
}

message GetFuturesLimit_Result {
    qlua.structs.FuturesLimit futures_limit = 1;
}

message GetFuturesHolding_Request {

    string firmid = 1;
    string trdaccid = 2;
    string sec_code = 3;
    int32 type = 4;
}

message GetFuturesHolding_Result {
    qlua.structs.FuturesClientHolding futures_holding = 1;
}

message GetSecurityInfo_Request {

    string class_code = 1;
    string sec_code = 2;
}

message GetSecurityInfo_Result {
    qlua.structs.Security security_info = 1;
}

message GetTradeDate_Result {

    message TradeDate {
    
        string date = 1;
        uint32 year = 2;
        uint32 month = 3;
        uint32 day = 4;
    }
    
    TradeDate trade_date = 1;
}

message GetQuoteLevel2_Request {

    string class_code = 1;
    string sec_code = 2;
}

message GetQuoteLevel2_Result {

    message QuoteEntry {
    
        string price = 1;
        string quantity = 2;
    }

    string bid_count = 1;
    string offer_count = 2;
    repeated QuoteEntry bids = 3;
    repeated QuoteEntry offers = 4;
}

message GetLinesCount_Request {
    string tag = 1;
}

message GetLinesCount_Result {
    int32 lines_count = 1;
}

message GetNumCandles_Request {
    string tag = 1;
}

message GetNumCandles_Result {
    int32 num_candles = 1;
}

message GetCandlesByIndex_Request {

    string tag = 1;
    int32 line = 2;
    int32 first_candle = 3;
    int32 count = 4;
}

message GetCandlesByIndex_Result {

    repeated qlua.structs.CandleEntry t = 1;
    int32 n = 2;
    string l = 3;
}

message CreateDataSource_Request {

    string class_code = 1;
    string sec_code = 2;
    Interval interval = 3;
    string param = 4;
}

message CreateDataSource_Result {

    string datasource_uuid = 1; 
    bool is_error = 2;
    string error_desc = 3;
}

message DataSourceSetUpdateCallback_Request {

    string datasource_uuid = 1; 
    string f_cb_def = 2; // NB: формат функции: "function (NUMBER index, TABLE datasource) function_body end"
}

message DataSourceSetUpdateCallback_Result {
    bool result = 1;
}

message DataSourceO_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceO_Result {
    string value = 1; // use of string instead of double for a safe money representation
}

message DataSourceH_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceH_Result {
    string value = 1; // use of string instead of double for a safe money representation
}

message DataSourceL_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceL_Result {
    string value = 1; // use of string instead of double for a safe money representation
}

message DataSourceC_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceC_Result {
    string value = 1; // use of string instead of double for a safe money representation
}

message DataSourceV_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceV_Result {
    string value = 1; // use of string instead of double for a safe quantity representation
}

message DataSourceT_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceT_Result {

    int32 year = 1;
    int32 month = 2;
    int32 day = 3;
    int32 week_day = 4;
    int32 hour = 5;
    int32 min = 6;
    int32 sec = 7;
    int32 ms = 8;
    int32 count = 9;
}

message DataSourceSize_Request {
    string datasource_uuid = 1;
}

message DataSourceSize_Result {
    int32 value = 1;
}

message DataSourceClose_Request {
    string datasource_uuid = 1;
}

message DataSourceClose_Result {
    bool result = 1;
}

message DataSourceSetEmptyCallback_Request {
    string datasource_uuid = 1;
}

message DataSourceSetEmptyCallback_Result {
    bool result = 1;
}

message SendTransaction_Request {
    map<string, string> transaction = 1;
}

message SendTransaction_Result {
    string result = 1;
}

message CalcBuySell_Request {

    string class_code = 1;
    string sec_code = 2;
    string client_code = 3;
    string account = 4;
    string price = 5;
    bool is_buy = 6;
    bool is_market = 7;
}

message CalcBuySell_Result {

    int32 qty = 1;
    string comission = 2;
}

message GetParamEx_Request {

    string class_code = 1;
    string sec_code = 2;
    string param_name = 3; // возможные значения для этого параметра можно найти тут: https://quikluacsharp.ru/quik-qlua/poluchenie-dannyh-iz-tablits-quik-v-qlua-lua/
}

message GetParamEx_Result {

    message ParamEx {
    
        string param_type = 1;
        string param_value = 2;
        string param_image = 3;
        string result = 4;
    }

    ParamEx param_ex = 1;
}

message GetPortfolioInfo_Request {

    string firm_id = 1;
    string client_code = 2;
}

message GetPortfolioInfo_Result {

    message PortfolioInfo {
    
        string is_leverage = 1;
        string in_assets = 2;
        string leverage = 3;
        string open_limit = 4;
        string val_short = 5;
        string val_long = 6;
        string val_long_margin = 7;
        string val_long_asset = 8;
        string assets = 9;
        string cur_leverage = 10;
        string margin = 11;
        string lim_all = 12;
        string av_lim_all = 13;
        string locked_buy = 14;
        string locked_buy_margin = 15;
        string locked_buy_asset = 16;
        string locked_sell = 17;
        string locked_value_coef = 18;
        string in_all_assets = 19;
        string all_assets = 20;
        string profit_loss = 21;
        string rate_change = 22;
        string lim_buy = 23;
        string lim_sell = 24;
        string lim_non_margin = 25;
        string lim_buy_asset = 26;
        string val_short_net = 27;
        string val_long_net = 28;
        string total_money_bal = 29;
        string total_locked_money = 30;
        string haircuts = 31;
        string assets_without_hc = 32;
        string status_coef = 33;
        string varmargin = 34;
        string go_for_positions = 35;
        string go_for_orders = 36;
        string rate_futures = 37;
        string is_qual_client = 38;
        string is_futures = 39;
        string curr_tag = 40;
    }

    PortfolioInfo portfolio_info = 1;
}

message GetPortfolioInfoEx_Request {

    string firm_id = 1;
    string client_code = 2;
    int32 limit_kind = 3;
}

message GetPortfolioInfoEx_Result {

    message PortfolioInfoEx {
    
        GetPortfolioInfo_Result.PortfolioInfo portfolio_info = 1;
        string init_margin = 2;
        string min_margin = 3;
        string corrected_margin = 4;
        string client_type = 5;
        string portfolio_value = 6;
        string start_limit_open_pos = 7;
        string total_limit_open_pos = 8;
        string limit_open_pos = 9;
        string used_lim_open_pos = 10;
        string acc_var_margin = 11;
        string cl_var_margin = 12;
        string opt_liquid_cost = 13;
        string fut_asset = 14;
        string fut_total_asset = 15;
        string fut_debt = 16;
        string fut_rate_asset = 17;
        string fut_rate_asset_open = 18;
        string fut_rate_go = 19;
        string planed_rate_go = 20;
        string cash_leverage = 21;
        string fut_position_type = 22;
        string fut_accured_int = 23;
    }

    PortfolioInfoEx portfolio_info_ex = 1;
}

message GetBuySellInfo_Request {

    string firm_id = 1;
    string client_code = 2;
    string class_code = 3;
    string sec_code = 4;
    string price = 5;
}

message GetBuySellInfo_Result {

    message BuySellInfo {
    
        string is_margin_sec = 1;
        string is_asset_sec = 2;
        string balance = 3;
        string can_buy = 4;
        string can_sell = 5;
        string position_valuation = 6;
        string value = 7;
        string open_value = 8;
        string lim_long = 9;
        string long_coef = 10;
        string lim_short = 11;
        string short_coef = 12;
        string value_coef = 13;
        string open_value_coef = 14;
        string share = 15;
        string short_wa_price = 16;
        string long_wa_price = 17;
        string profit_loss = 18;
        string spread_hc = 19;
        string can_buy_own = 20;
        string can_sell_own = 21;
    }
    
    BuySellInfo buy_sell_info = 1;
}

message GetBuySellInfoEx_Request {

    string firm_id = 1;
    string client_code = 2;
    string class_code = 3;
    string sec_code = 4;
    string price = 5;
}

message GetBuySellInfoEx_Result {

    message BuySellInfoEx {
    
        GetBuySellInfo_Result.BuySellInfo buy_sell_info = 1;
        string limit_kind = 2; // NUMBER in QLUA
        string d_long = 3;
        string d_min_long = 4;
        string d_short = 5;
        string d_min_short = 6;
        string client_type = 7;
        string is_long_allowed = 8;
        string is_short_allowed = 9;
    }

    BuySellInfoEx buy_sell_info_ex = 1;
}

// Важно! Это не указано в документации к Quik:
// добавлять столбцы нужно перед вызовом CreateWindow для указанной таблице. Иначе потом
// вызовы AddColumn будут возвращать ответ, что столбец добавлен, но визуально ничего не изменится.
// Я даже пробовал скрывать таблицу и создавать новое окно для неё, но всё равно добавленные 
// между делом столбцы не отобразились.
message AddColumn_Request {

    int32 t_id = 1;
    int32 icode = 2;
    string name = 3;
    bool is_default = 4;
    ColumnParameterType par_type = 5;
    int32 width = 6;
}

message AddColumn_Result {
    int32 result = 1;
}

message AllocTable_Result {
    int32 t_id = 1;
}

message Clear_Request {
    int32 t_id = 1;
}

message Clear_Result {
    bool result = 1;
}

message CreateWindow_Request {
    int32 t_id = 1;
}

message CreateWindow_Result {
    int32 result = 1;
}

message DeleteRow_Request {

    int32 t_id = 1;
    int32 key = 2;
}

message DeleteRow_Result {
    bool result = 1;
}

message DestroyTable_Request {
    int32 t_id = 1;
}

message DestroyTable_Result {
    bool result = 1;
}

message InsertRow_Request {

    int32 t_id = 1;
    int32 key = 2;
}

message InsertRow_Result {
    int32 result = 1;
}

message IsWindowClosed_Request {
    int32 t_id = 1;
}

message IsWindowClosed_Result {
    bool result = 1;
}

message GetCell_Request {

    int32 t_id = 1;
    int32 key = 2;
    int32 code = 3;
}

message GetCell_Result {

    string image = 1;
    string value = 2; // the parsing is left to be done on the client side, the library returns it as 0 if the cell's number is not set, so "0" goes on the wire in that case
}

message SetCell_Request {

    int32 t_id = 1;
    int32 key = 2;
    int32 code = 3;
    string text = 4;
    string value = 5;
}

message SetCell_Result {
    bool result = 1;
}

message SetWindowCaption_Request {

    int32 t_id = 1;
    string str = 2;
}

message SetWindowCaption_Result {
    bool result = 1;
}

message SetWindowPos_Request {

    int32 t_id = 1;
    int32 x = 2;
    int32 y = 3;
    int32 dx = 4;
    int32 dy = 5;
}

message SetWindowPos_Result {
    bool result = 1;
}

message SetTableNotificationCallback_Request {

    int32 t_id = 1;
    string f_cb_def = 2;
}

message SetTableNotificationCallback_Result {
    int32 result = 1;
}

message GetTableSize_Request {
    int32 t_id = 1;
}

message GetTableSize_Result {

    int32 rows = 1;
    int32 col = 2;
}

message GetWindowCaption_Request {
    int32 t_id = 1;
}

message GetWindowCaption_Result {
    string caption = 1;
}

message GetWindowRect_Request {
    int32 t_id = 1;
}

message GetWindowRect_Result {

    int32 top = 1;
    int32 left = 2;
    int32 bottom = 3;
    int32 right = 4;
}

// NB: на самом деле, библиотечная функция RGB должна называться BGR, ибо она выдаёт числа именно в этом формате. В SetColor, однако, тоже ожидается цвет в формате BGR, так что это не баг, а фича.
message RGB_Request {

    int32 red = 1;
    int32 green = 2;
    int32 blue = 3;
}

message RGB_Result {
    int32 result = 1;
}

message SetColor_Request {

    int32 t_id = 1;
    int32 row = 2;
    int32 col = 3;
    int32 b_color = 4;
    int32 f_color = 5;
    int32 sel_b_color = 6;
    int32 sel_f_color = 7;
}

message SetColor_Result {
    bool result = 1;
}

message Highlight_Request {

    int32 t_id = 1;
    int32 row = 2;
    int32 col = 3;
    int32 b_color = 4;
    int32 f_color = 5;
    int64 timeout = 6;
}

message Highlight_Result {
    bool result = 1;
}

message SetSelectedRow_Request {

    int32 table_id = 1;
    int32 row = 2;
}

message SetSelectedRow_Result {
    int32 result = 1;
}

message AddLabel_Request {

    string chart_tag = 1;
    map<string, string> label_params = 2;
}

message AddLabel_Result {
    int32 label_id = 1;
}

message DelLabel_Request {

    string chart_tag = 1;
    int32 label_id = 2;
}

message DelLabel_Result {
    bool result = 1;
}

message DelAllLabels_Request {
    string chart_tag = 1;
}

message DelAllLabels_Result {
    bool result = 1;
}

message GetLabelParams_Request {

    string chart_tag = 1;
    int32 label_id = 2;
}

message GetLabelParams_Result {
    map<string, string> label_params = 1;
}

message SetLabelParams_Request {

    string chart_tag = 1;
    int32 label_id = 2;
    map<string, string> label_params = 3;
}

message SetLabelParams_Result {
    bool result = 1;
}

message SubscribeLevel2Quotes_Request {

    string class_code = 1;
    string sec_code = 2;
}

message SubscribeLevel2Quotes_Result {
    bool result = 1;
}

message UnsubscribeLevel2Quotes_Request {

    string class_code = 1;
    string sec_code = 2;
}

message UnsubscribeLevel2Quotes_Result {
    bool result = 1;
}

message IsSubscribedLevel2Quotes_Request {

    string class_code = 1;
    string sec_code = 2;
}

message IsSubscribedLevel2Quotes_Result {
    bool result = 1;
}

message ParamRequest_Request {

    string class_code = 1;
    string sec_code = 2;
    string db_name = 3;
}

message ParamRequest_Result {
    bool result = 1;
}

message CancelParamRequest_Request {

    string class_code = 1;
    string sec_code = 2;
    string db_name = 3;
}

message CancelParamRequest_Result {
    bool result = 1;
}

message BitToHex_Request {

    int32 x = 1;
    int32 n = 2; // 0 counts as "parameter not set"
}

message BitToHex_Result {
    string result = 1;
}

message BitBNot_Request {
    int32 x = 1;
}

message BitBNot_Result {
    int32 result = 1;
}

message BitBAnd_Request {

    int32 x1 = 1;
    int32 x2 = 2;
    repeated int32 xi = 3;
}

message BitBAnd_Result {
    int32 result = 1;
}

message BitBOr_Request {

    int32 x1 = 1;
    int32 x2 = 2;
    repeated int32 xi = 3;
}

message BitBOr_Result {
    int32 result = 1;
}

message BitBXor_Request {

    int32 x1 = 1;
    int32 x2 = 2;
    repeated int32 xi = 3;
}

message BitBXor_Result {
    int32 result = 1;
}
